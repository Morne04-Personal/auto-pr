run: |
  echo "Reviewing PR #$PR_NUMBER"
  echo "---NODE SCRIPT---"
  echo '
    const { Octokit } = require("@octokit/rest");
    const https = require("https");

    const githubToken = process.env.GITHUB_TOKEN;
    const geminiApiKey = process.env.GEMINI_API_KEY;
    const prNumber = process.env.PR_NUMBER;
    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO;

    async function getDiff(octokit, owner, repo, prNumber) {
      const { data: diff } = await octokit.pulls.get({
        owner,
        repo,
        pull_number: prNumber,
        mediaType: {
          format: "diff",
        },
      });
      return diff;
    }

    async function generateGeminiReview(diff) {
      const model = "gemini-1.5-pro-latest"; // or "gemini-pro" if you dont have access to 1.5
      const apiUrl = `https://generativeai.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

      const requestData = JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: `Review this code diff for potential issues, bugs, security vulnerabilities, and style violations. Provide specific line numbers and file paths where problems are found. Use Markdown formatting to highlight code snippets. For each issue, include a brief explanation. Focus on practical and actionable suggestions. Be concise. The code diff:\\n${diff}`,
              },
            ],
          },
        ],
      });

      return new Promise((resolve, reject) => {
        const options = {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        };

        const req = https.request(apiUrl, options, (res) => {
          let data = "";

          res.on("data", (chunk) => {
            data += chunk;
          });

          res.on("end", () => {
            try {
              const responseData = JSON.parse(data);
              const reviewText = responseData.candidates[0].content.parts[0].text;
              console.log("Gemini Review:", reviewText);
              resolve(reviewText);
            } catch (error) {
              reject(new Error(`Error parsing Gemini response: ${error.message}, raw data: ${data}`));
            }
          });
        });

        req.on("error", (error) => {
          reject(new Error(`Gemini API request failed: ${error.message}`));
        });

        req.write(requestData);
        req.end();
      });
    }

    async function postGitHubComments(octokit, owner, repo, prNumber, geminiReview) {
      const commentRegex = /^(.*?)(Line\\s+\\d+,\\s+.*?):(.*)$/gm;
      let match;
      const comments = [];

      while ((match = commentRegex.exec(geminiReview)) !== null) {
          const filePath = match[1].trim();
          const lineInfo = match[2].trim();
          const commentBody = match[3].trim();
          const lineNumberMatch = lineInfo.match(/Line\\s+(\\d+)/);
          const lineNumber = lineNumberMatch ? parseInt(lineNumberMatch[1]) : null;
          comments.push({ filePath, lineNumber, commentBody });
      }
      console.log("Parsed Comments:", comments);
      // Iterate through the comments and post them to the pull request.
      for (const comment of comments) {

          if (comment.lineNumber !== null) {
            try {
              await octokit.pulls.createReviewComment({
                owner,
                repo,
                pull_number: prNumber,
                body: comment.commentBody,
                path: comment.filePath, // Determine this from the comment body. Needs to be extracted or Gemini can provide it.
                position: comment.lineNumber,
              });
              console.log("Comment posted to line:", comment.lineNumber);
            } catch (error) {
              console.error(`Error posting comment to line: ${comment.lineNumber}, error: ${error}`);
            }
          } else {
            console.warn(`Could not find line number for comment: ${comment.commentBody}`);
          }
      }
    }

    async function main() {
      const octokit = new Octokit({ auth: githubToken });

      try {
        const diff = await getDiff(octokit, owner, repo, prNumber);
        const geminiReview = await generateGeminiReview(diff);

        await postGitHubComments(octokit, owner, repo, prNumber, geminiReview);
      } catch (error) {
        console.error(`Error reviewing pull request: ${error}`);
        process.exit(1);
      }
    }

    main().catch((error) => {
      console.error(error);
      process.exit(1);
    });
  '
  echo "---END NODE SCRIPT---"
  node -e '
    const { Octokit } = require("@octokit/rest");
    const https = require("https");

    const githubToken = process.env.GITHUB_TOKEN;
    const geminiApiKey = process.env.GEMINI_API_KEY;
    const prNumber = process.env.PR_NUMBER;
    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO;

    async function getDiff(octokit, owner, repo, prNumber) {
      const { data: diff } = await octokit.pulls.get({
        owner,
        repo,
        pull_number: prNumber,
        mediaType: {
          format: "diff",
        },
      });
      return diff;
    }

    async function generateGeminiReview(diff) {
      const model = "gemini-1.5-pro-latest"; // or "gemini-pro" if you dont have access to 1.5
      const apiUrl = `https://generativeai.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

      const requestData = JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: `Review this code diff for potential issues, bugs, security vulnerabilities, and style violations. Provide specific line numbers and file paths where problems are found. Use Markdown formatting to highlight code snippets. For each issue, include a brief explanation. Focus on practical and actionable suggestions. Be concise. The code diff:\\n${diff}`,
              },
            ],
          },
        ],
      });

      return new Promise((resolve, reject) => {
        const options = {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        };

        const req = https.request(apiUrl, options, (res) => {
          let data = "";

          res.on("data", (chunk) => {
            data += chunk;
          });

          res.on("end", () => {
            try {
              const responseData = JSON.parse(data);
              const reviewText = responseData.candidates[0].content.parts[0].text;
              console.log("Gemini Review:", reviewText);
              resolve(reviewText);
            } catch (error) {
              reject(new Error(`Error parsing Gemini response: ${error.message}, raw data: ${data}`));
            }
          });
        });

        req.on("error", (error) => {
          reject(new Error(`Gemini API request failed: ${error.message}`));
        });

        req.write(requestData);
        req.end();
      });
    }

    async function postGitHubComments(octokit, owner, repo, prNumber, geminiReview) {
      const commentRegex = /^(.*?)(Line\\s+\\d+,\\s+.*?):(.*)$/gm;
      let match;
      const comments = [];

      while ((match = commentRegex.exec(geminiReview)) !== null) {
          const filePath = match[1].trim();
          const lineInfo = match[2].trim();
          const commentBody = match[3].trim();
          const lineNumberMatch = lineInfo.match(/Line\\s+(\\d+)/);
          const lineNumber = lineNumberMatch ? parseInt(lineNumberMatch[1]) : null;
          comments.push({ filePath, lineNumber, commentBody });
      }
      console.log("Parsed Comments:", comments);
      // Iterate through the comments and post them to the pull request.
      for (const comment of comments) {

          if (comment.lineNumber !== null) {
            try {
              await octokit.pulls.createReviewComment({
                owner,
                repo,
                pull_number: prNumber,
                body: comment.commentBody,
                path: comment.filePath, // Determine this from the comment body. Needs to be extracted or Gemini can provide it.
                position: comment.lineNumber,
              });
              console.log("Comment posted to line:", comment.lineNumber);
            } catch (error) {
              console.error(`Error posting comment to line: ${comment.lineNumber}, error: ${error}`);
            }
          } else {
            console.warn(`Could not find line number for comment: ${comment.commentBody}`);
          }
      }
    }

    async function main() {
      const octokit = new Octokit({ auth: githubToken });

      try {
        const diff = await getDiff(octokit, owner, repo, prNumber);
        const geminiReview = await generateGeminiReview(diff);

        await postGitHubComments(octokit, owner, repo, prNumber, geminiReview);
      } catch (error) {
        console.error(`Error reviewing pull request: ${error}`);
        process.exit(1);
      }
    }

    main().catch((error) => {
      console.error(error);
      process.exit(1);
    });
  '