name: Auto Pull Request with Gemini Review (Direct API Key)

on:
  push:
    branches:
      - main

jobs:
  create_pr_and_review:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check for Existing PR
        id: check_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there is an open PR for the same branch/commit
          PR_EXISTS=$(gh pr list --head "auto-pr/${{ github.sha }}" --state open --json number -q ".[].number" --repo "${{ github.repository }}" | jq -r '. // empty')

          if [[ -n "$PR_EXISTS" ]]; then
            echo "::set-output name=pr_exists::true"
            echo "Existing PR found: $PR_EXISTS"
          else
            echo "::set-output name=pr_exists::false"
          fi
        shell: bash
        if: github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Install Dependencies
        run: |
          npm install @octokit/rest
          npm install @google/generative-ai
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Create Pull Request
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure Git identity
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          # Get the current and previous commit SHAs
          CURRENT_SHA=$(git rev-parse HEAD)
          PREVIOUS_SHA=$(git rev-parse HEAD~1)

          # Get the commit message (first line)
          COMMIT_MESSAGE=$(git log -1 --pretty=%B | head -n 1)
          COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed 's/[^a-zA-Z0-9_-]/ /g' | tr -s ' ') # Sanitize commit message
          # Create a timestamp for uniqueness
          TIMESTAMP=$(date +%s)

          # Create a new branch from the previous commit
          BRANCH_NAME="auto-pr/${COMMIT_MESSAGE}-$CURRENT_SHA-$TIMESTAMP" # Include sanitized commit message in branch name
          git checkout -b "$BRANCH_NAME" $PREVIOUS_SHA

          # Cherry-pick the current commit onto the new branch
          git cherry-pick $CURRENT_SHA

          # Push the branch with the cherry-picked commit
          git push origin "$BRANCH_NAME"

          # Create Pull Request using Node.js
          PR_NUMBER=$(node -e "
            process.env.COMMIT_MESSAGE = '$COMMIT_MESSAGE';
            process.env.BRANCH_NAME = '$BRANCH_NAME';
            process.env.CURRENT_SHA = '$CURRENT_SHA';

            async function main() {
              const { Octokit } = await import('@octokit/rest');
              const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

              try {
                const owner = process.env.GITHUB_REPOSITORY_OWNER;
                const repo = process.env.GITHUB_REPOSITORY.split('/')[1];

                const response = await octokit.pulls.create({
                  owner,
                  repo,
                  title: process.env.COMMIT_MESSAGE,
                  head: process.env.BRANCH_NAME,
                  base: 'main',
                  body: 'Automated PR for commit ' + process.env.CURRENT_SHA + '\\nCommit message: ' + process.env.COMMIT_MESSAGE,
                });

                console.log('Pull request created:', response.data.html_url);
                console.log('::set-output name=pr_number::' + response.data.number); // Set output for next step
                process.exit(0);
              } catch (error) {
                console.error('Error creating pull request:', error);
                process.exit(1);
              }
            }

            main().catch((error) => {
              console.error(error);
              process.exit(1);
            });
          ")
          echo "PR Number: $PR_NUMBER"
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Review Pull Request with Gemini
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
          GITHUB_OWNER: ${{ github.repository_owner }}
          GITHUB_REPO: ${{ github.event.repository.name }}
        run: |
          echo "Reviewing PR #$PR_NUMBER"

          node -e '
            async function main() {
              const { Octokit } = await import("@octokit/rest");
              const { GoogleGenerativeAI } = await import("@google/generative-ai");

              const githubToken = process.env.GITHUB_TOKEN;
              const geminiApiKey = process.env.GEMINI_API_KEY;
              const prNumber = process.env.PR_NUMBER;
              const owner = process.env.GITHUB_OWNER;
              const repo = process.env.GITHUB_REPO;

              async function getDiff(octokit, owner, repo, prNumber) {
                try{
                  const { data: diff } = await octokit.pulls.get({
                    owner,
                    repo,
                    pull_number: prNumber,
                    mediaType: {
                      format: "diff",
                    },
                  });
                  return diff;
                } catch (error){
                  console.log("Octokit Error:", error);
                  throw error;
                }
              }

              async function generateGeminiReview(diff) {
                try{
                  const genAI = new GoogleGenerativeAI(geminiApiKey);
                  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

                  const prompt = `Review this code diff for potential issues, bugs, security vulnerabilities, and style violations. Provide specific line numbers and file paths where problems are found. Use Markdown formatting to highlight code snippets. For each issue, include a brief explanation. Focus on practical and actionable suggestions. Be concise.  Please return the information as a JSON blob, with the following format:

                  \`\`\`json
                  {
                    "comments": [
                      {
                        "filePath": "path/to/file.js",
                        "lineNumber": 123,
                        "body": "Potential bug: ...",
                        "severity": "warning"
                      },
                      {
                        "filePath": "path/to/another/file.js",
                        "lineNumber": 45,
                        "body": "Consider using a more descriptive variable name.",
                        "severity": "suggestion"
                      }
                    ]
                  }
                  \`\`\`

                  The code diff:\\n${diff}`;

                  const result = await model.generateContent(prompt);
                  console.log("Full Gemini API Response:", JSON.stringify(result, null, 2));

                  // Check if result.response exists
                  if (!result || !result.response) {
                    console.error("Gemini API Response Error: Missing 'response' property");
                    throw new Error("Invalid Gemini API response format: Missing 'response' property");
                  }

                  // Check if result.response.candidates exists and is an array
                  if (!result.response.candidates || !Array.isArray(result.response.candidates) || !result.response.candidates.length === 0) {
                    console.error("Gemini API Response Error: No candidates found or invalid format");
                    throw new Error("Invalid Gemini API response format: Missing candidates");
                  }

                  // Check if result.response.candidates[0].content exists and has parts
                  if (!result.response.candidates[0] || !result.response.candidates[0].content || !result.response.candidates[0].content.parts || !Array.isArray(result.response.candidates[0].content.parts) || result.response.candidates[0].content.parts.length === 0) {
                    console.error("Gemini API Response Error: No content or parts found in the first candidate");
                    throw new Error("Invalid Gemini API response format: Missing content or parts");
                  }

                  // Check if result.promptFeedback exists and log it
                  if (result.promptFeedback) {
                    console.log("Gemini Prompt Feedback:", JSON.stringify(result.promptFeedback, null, 2));
                  }

                  const responseText = result.response.candidates[0].content.parts[0].text;
                  console.log("Gemini Review:", responseText);
                  return responseText;
                } catch (error) {
                  console.error("Gemini API Error:", error);
                  throw error; // Re-throw to stop the workflow
                }
              }

              async function postGitHubComments(octokit, owner, repo, prNumber, geminiReview) {
                try {
                    const reviewData = JSON.parse(geminiReview);

                    if (!reviewData || !Array.isArray(reviewData.comments)) {
                        console.error("Invalid review data format.");
                        return;
                    }

                    for (const comment of reviewData.comments) {
                        if (comment.filePath && comment.lineNumber && comment.body) {
                            try {
                                await octokit.pulls.createReviewComment({
                                    owner,
                                    repo,
                                    pull_number: prNumber,
                                    body: comment.body,
                                    path: comment.filePath,
                                    position: comment.lineNumber,
                                });
                                console.log(`Comment posted to line: ${comment.lineNumber} in ${comment.filePath}`);
                            } catch (error) {
                                console.error(`Error posting comment to line: ${comment.lineNumber} in ${comment.filePath}:`, error);
                            }
                        } else {
                            console.warn("Skipping invalid comment:", comment);
                        }
                    }
                } catch (error) {
                    console.error("Error parsing or processing Gemini review:", error);
                }
              }

              try {
                const octokit = new Octokit({ auth: githubToken });
                const diff = await getDiff(octokit, owner, repo, prNumber);
                const geminiReview = await generateGeminiReview(diff);
                await postGitHubComments(octokit, owner, repo, prNumber, geminiReview);

              } catch (error) {
                console.error(`Error reviewing pull request: ${error}`);
                process.exit(1);
              }
            }

            main().catch((error) => {
              console.error(error);
              process.exit(1);
            });
          '
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')