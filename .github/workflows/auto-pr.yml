name: Auto Pull Request with Gemini Review (Direct API Key)

on:
  push:
    branches:
      - main

jobs:
  create_pr_and_review:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check for Existing PR
        id: check_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there is an open PR for the same branch/commit
          PR_EXISTS=$(gh pr list --head "auto-pr/${{ github.sha }}" --state open --json number -q ".[].number" --repo "${{ github.repository }}" | jq -r '. // empty')

          if [[ -n "$PR_EXISTS" ]]; then
            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "Existing PR found: $PR_EXISTS"
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
          fi
        shell: bash
        if: github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Install Dependencies
        run: |
          npm install @octokit/rest
          npm install @google/generative-ai
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Create Pull Request
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure Git identity
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          # Get the current and previous commit SHAs
          CURRENT_SHA=$(git rev-parse HEAD)
          PREVIOUS_SHA=$(git rev-parse HEAD~1)

          # Create a timestamp for uniqueness
          TIMESTAMP=$(date +%s)

          # Create a new branch from the previous commit
          BRANCH_NAME="auto-pr/$CURRENT_SHA-$TIMESTAMP"
          git checkout -b "$BRANCH_NAME" $PREVIOUS_SHA

          # Cherry-pick the current commit onto the new branch
          git cherry-pick $CURRENT_SHA

          # Push the branch with the cherry-picked commit
          git push origin "$BRANCH_NAME"

          # Get the commit message
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)

          # Create Pull Request using gh cli
          PR_URL=$(gh pr create --title "$COMMIT_MESSAGE" --body "Automated PR for commit $CURRENT_SHA" --head "$BRANCH_NAME" --base main --repo ${{ github.repository }})

          # Extract the PR number from the URL
          PR_NUMBER=$(echo "$PR_URL" | awk -F'/' '{print $NF}')

          echo "PR Number: $PR_NUMBER"
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

        shell: bash
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Review Pull Request with Gemini
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
          GITHUB_OWNER: ${{ github.repository_owner }}
          GITHUB_REPO: ${{ github.event.repository.name }}
        run: |
          echo "Reviewing PR #$PR_NUMBER"

          node -e '
            async function main() {
              const { Octokit } = await import("@octokit/rest");
              const { GoogleGenerativeAI } = await import("@google/generative-ai");

              const githubToken = process.env.GITHUB_TOKEN;
              const geminiApiKey = process.env.GEMINI_API_KEY;
              const prNumber = process.env.PR_NUMBER;
              const owner = process.env.GITHUB_OWNER;
              const repo = process.env.GITHUB_REPO;

              async function getDiff(octokit, owner, repo, prNumber) {
                try {
                  const { data: diff } = await octokit.pulls.get({
                    owner,
                    repo,
                    pull_number: prNumber,
                    mediaType: {
                      format: "diff",
                    },
                  });
                  return diff;
                } catch (error) {
                  console.log("Octokit Error:", error);
                  throw error;
                }
              }

              async function generateGeminiReview(diff) {
                try {
                  const genAI = new GoogleGenerativeAI(geminiApiKey);
                  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

                  const prompt = `Review this code diff for potential issues, bugs, security vulnerabilities, and style violations. Provide Markdown formatting to highlight code snippets. For each issue, include a brief explanation. Focus on practical and actionable suggestions. Be concise. Please return the information as a JSON blob, with the following format:

                  {
                    "comments": [
                      {
                        "filePath": "path/to/file.js",
                        "lineNumber": 123,
                        "body": "Potential bug: ...",
                        "severity": "warning"
                      }
                    ]
                  }

                  The code diff:\\n${diff}`;
                  
                  const result = await model.generateContent({
                    contents: [
                      {
                        role: "user",
                        parts: [
                          {
                            text: prompt
                          }
                        ]
                      }
                    ]
                  });

                  if (!result?.response) {
                    throw new Error("Invalid Gemini API response format: Missing 'response' property");
                  }

                  if (!result.response.candidates?.[0]?.content?.parts?.[0]) {
                    throw new Error("Invalid Gemini API response format: Missing content");
                  }

                  const responseText = result.response.candidates[0].content.parts[0].text;
                  console.log("Gemini Review:", responseText);
                  return responseText;
                } catch (error) {
                  console.error("Gemini API Error:", error);
                  throw error;
                }
              }

              async function postGitHubComments(octokit, owner, repo, prNumber, geminiReview) {
                try {
                  const trimmedReview = geminiReview.trim();
                  let reviewData;
                  
                  try {
                    // First try parsing directly
                    reviewData = JSON.parse(trimmedReview);
                  } catch (error) {
                    // If direct parsing fails, try removing markdown code fences
                    const jsonString = trimmedReview
                      .replace(/^```json\s*/, "")
                      .replace(/```\s*$/, "");
                    reviewData = JSON.parse(jsonString);
                  }

                  if (!reviewData?.comments?.length) {
                    console.error("Invalid review data format: 'comments' property missing or empty.");
                    return;
                  }

                  // Create a review first
                  const review = await octokit.pulls.createReview({
                    owner,
                    repo,
                    pull_number: prNumber,
                    event: "COMMENT"
                  });

                  // Add comments in batches to avoid rate limits
                  const batchSize = 5;
                  for (let i = 0; i < reviewData.comments.length; i += batchSize) {
                    const batch = reviewData.comments.slice(i, i + batchSize);
                    await Promise.all(batch.map(async (comment) => {
                      if (comment.filePath && comment.lineNumber && comment.body) {
                        try {
                          await octokit.pulls.createReviewComment({
                            owner,
                            repo,
                            pull_number: prNumber,
                            body: `${comment.severity.toUpperCase()}: ${comment.body}`,
                            path: comment.filePath,
                            line: comment.lineNumber,
                            side: "RIGHT"
                          });
                          console.log(`Comment posted to line ${comment.lineNumber} in ${comment.filePath}`);
                        } catch (error) {
                          console.error(`Error posting comment: ${error.message}`);
                        }
                      }
                    }));
                    
                    // Add a small delay between batches
                    if (i + batchSize < reviewData.comments.length) {
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                  }
                } catch (error) {
                  console.error("Error processing review:", error);
                  throw error;
                }
              }

              try {
                const octokit = new Octokit({ auth: githubToken });
                const diff = await getDiff(octokit, owner, repo, prNumber);
                const geminiReview = await generateGeminiReview(diff);
                await postGitHubComments(octokit, owner, repo, prNumber, geminiReview);
              } catch (error) {
                console.error(`Error reviewing pull request: ${error}`);
                process.exit(1);
              }
            }

            main().catch((error) => {
              console.error(error);
              process.exit(1);
            });
          '
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')