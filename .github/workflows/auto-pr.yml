name: Auto Pull Request with Gemini Review (Direct API Key)

on:
  push:
    branches:
      - main

jobs:
  create_pr_and_review:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check for Existing PR
        id: check_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Check if there is an open PR for the same branch/commit
          PR_EXISTS=$(gh pr list --head "auto-pr/${{ github.sha }}" --state open --json number -q ".[].number" --repo "${{ github.repository }}" | jq -r '. // empty')

          if [[ -n "$PR_EXISTS" ]]; then
            echo "pr_exists=true" >> $GITHUB_OUTPUT
            echo "Existing PR found: $PR_EXISTS"
          else
            echo "pr_exists=false" >> $GITHUB_OUTPUT
          fi
        shell: bash
        if: github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Install Dependencies
        run: |
          npm install @octokit/rest
          npm install @google/generative-ai
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Create Pull Request
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure Git identity
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          # Get the current and previous commit SHAs
          CURRENT_SHA=$(git rev-parse HEAD)
          PREVIOUS_SHA=$(git rev-parse HEAD~1)

          # Create a timestamp for uniqueness
          TIMESTAMP=$(date +%s)

          # Create a new branch from the previous commit
          BRANCH_NAME="auto-pr/$CURRENT_SHA-$TIMESTAMP"
          git checkout -b "$BRANCH_NAME" $PREVIOUS_SHA

          # Cherry-pick the current commit onto the new branch
          git cherry-pick $CURRENT_SHA

          # Push the branch with the cherry-picked commit
          git push origin "$BRANCH_NAME"

          # Get the commit message
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)

          # Create Pull Request using gh cli
          PR_URL=$(gh pr create --title "$COMMIT_MESSAGE" --body "Automated PR for commit $CURRENT_SHA" --head "$BRANCH_NAME" --base main --repo ${{ github.repository }})

          # Extract the PR number from the URL
          PR_NUMBER=$(echo "$PR_URL" | awk -F'/' '{print $NF}')

          echo "PR Number: $PR_NUMBER"
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

        shell: bash
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')

      - name: Review Pull Request with Gemini
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
          GITHUB_OWNER: ${{ github.repository_owner }}
          GITHUB_REPO: ${{ github.event.repository.name }}
        run: |
          echo "Reviewing PR #$PR_NUMBER"

          node -e '
            async function main() {
              const { Octokit } = await import("@octokit/rest");
              const { GoogleGenerativeAI } = await import("@google/generative-ai");

              const githubToken = process.env.GITHUB_TOKEN;
              const geminiApiKey = process.env.GEMINI_API_KEY;
              const prNumber = process.env.PR_NUMBER;
              const owner = process.env.GITHUB_OWNER;
              const repo = process.env.GITHUB_REPO;

              async function getDiff(octokit, owner, repo, prNumber) {
                try {
                  const { data: diff } = await octokit.pulls.get({
                    owner,
                    repo,
                    pull_number: prNumber,
                    mediaType: {
                      format: "diff",
                    },
                  });
                  return diff;
                } catch (error) {
                  console.log("Octokit Error:", error);
                  throw error;
                }
              }

              async function generateGeminiReview(diff) {
                try {
                  const genAI = new GoogleGenerativeAI(geminiApiKey);
                  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });

                  const prompt = `Review this code diff for potential issues, bugs, security vulnerabilities, and style violations. For each issue, include a brief explanation and mark its severity (info, suggestion, warning, or error). Return the review as a JSON object with an array of comments. Each comment should include the file path, line number in the new version of the file, and the comment text. Format the response exactly like this:

                  {
                    "comments": [
                      {
                        "filePath": "path/to/file.js",
                        "lineNumber": 123,
                        "body": "Consider using a more descriptive variable name.",
                        "severity": "suggestion"
                      }
                    ]
                  }

                  Code diff to review:\\n${diff}`;
                  
                  const result = await model.generateContent({
                    contents: [
                      {
                        role: "user",
                        parts: [{ text: prompt }]
                      }
                    ],
                    generationConfig: {
                      temperature: 0.7,
                      topP: 0.8,
                      topK: 40,
                    }
                  });

                  if (!result?.response) {
                    throw new Error("Invalid Gemini API response format: Missing 'response' property");
                  }

                  if (!result.response.candidates?.[0]?.content?.parts?.[0]) {
                    throw new Error("Invalid Gemini API response format: Missing content");
                  }

                  const responseText = result.response.candidates[0].content.parts[0].text;
                  
                  // Clean up the response text to ensure valid JSON
                  const cleanedText = responseText.replace(/^```json\s*|\s*```$/g, "").trim();
                  
                  try {
                    // Validate that the response is parseable JSON
                    JSON.parse(cleanedText);
                    return cleanedText;
                  } catch (parseError) {
                    console.error("Error parsing Gemini response as JSON:", parseError);
                    throw new Error("Invalid JSON response from Gemini");
                  }
                } catch (error) {
                  console.error("Gemini API Error:", error);
                  throw error;
                }
              }

              async function postGitHubComments(octokit, owner, repo, prNumber, geminiReview) {
                try {
                  let reviewData;
                  
                  try {
                    reviewData = JSON.parse(geminiReview);
                  } catch (error) {
                    console.error("Error parsing review JSON:", error);
                    throw new Error("Invalid review data format");
                  }

                  if (!reviewData?.comments?.length) {
                    console.error("No comments found in review data");
                    return;
                  }

                  // Transform comments for GitHub review API
                  const comments = reviewData.comments.map(comment => ({
                    path: comment.filePath,
                    line: parseInt(comment.lineNumber, 10),
                    body: `**${comment.severity.toUpperCase()}:** ${comment.body}`,
                    side: 'RIGHT'
                  }));

                  try {
                    // Create a single review with all comments
                    const review = await octokit.pulls.createReview({
                      owner,
                      repo,
                      pull_number: prNumber,
                      event: 'COMMENT',
                      comments: comments,
                      body: '## Code Review by Gemini AI\n\nI have reviewed the changes and provided inline comments.'
                    });
                    console.log('Review created successfully');
                  } catch (reviewError) {
                    console.error('Error creating review:', reviewError.message);
                    console.log('Falling back to individual comments...');

                    // Fallback: Post comments individually
                    const batchSize = 5;
                    for (let i = 0; i < comments.length; i += batchSize) {
                      const batch = comments.slice(i, i + batchSize);
                      await Promise.all(batch.map(async (comment) => {
                        try {
                          await octokit.pulls.createReviewComment({
                            owner,
                            repo,
                            pull_number: prNumber,
                            body: comment.body,
                            path: comment.path,
                            line: comment.line,
                            side: comment.side
                          });
                          console.log(`Comment posted to line ${comment.line} in ${comment.path}`);
                        } catch (error) {
                          console.error(`Error posting comment: ${error.message}`);
                        }
                      }));
                      
                      if (i + batchSize < comments.length) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                      }
                    }
                  }
                } catch (error) {
                  console.error("Error processing review:", error);
                  // Log error but allow workflow to continue
                  console.log("Continuing workflow despite review error");
                }
              }

              try {
                const octokit = new Octokit({ auth: githubToken });
                const diff = await getDiff(octokit, owner, repo, prNumber);
                const geminiReview = await generateGeminiReview(diff);
                await postGitHubComments(octokit, owner, repo, prNumber, geminiReview);
              } catch (error) {
                console.error(`Error reviewing pull request: ${error}`);
                process.exit(1);
              }
            }

            main().catch((error) => {
              console.error(error);
              process.exit(1);
            });
          '
        if: steps.check_pr.outputs.pr_exists == 'false' && github.event.head_commit.message != null && ! startsWith(github.event.head_commit.message, 'Merge pull request')